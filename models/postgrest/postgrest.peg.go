package postgrest

// Code generated by peg postgrest.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleQueryString
	ruleQueryParam
	ruleLogicalQuery
	ruleFilterList
	ruleFilterExpression
	ruleLogicalFilter
	ruleLogicalOperator
	ruleBinaryOperator
	ruleSelect
	ruleSelectOptions
	ruleSelectOption
	ruleSelectColumn
	ruleAggregation
	ruleAggregationOption
	ruleSelectCount
	ruleRenamed
	ruleCast
	ruleLimit
	ruleOffset
	ruleOrder
	ruleFilter
	ruleOrderOptions
	ruleOrderOption
	ruleColumnName
	ruleOrderDirection
	ruleNullDirection
	rulePredicate
	ruleNot
	ruleOperator
	ruleAnyAll
	ruleOperand
	ruleListOperand
	ruleListOperandItem
	ruleVectorOperand
	ruleVectorOperandItem
	ruleQuotedString
	ruleEscapedChar
	ruleScalarOperand
	ruleInteger
	ruleEND
)

var rul3s = [...]string{
	"Unknown",
	"QueryString",
	"QueryParam",
	"LogicalQuery",
	"FilterList",
	"FilterExpression",
	"LogicalFilter",
	"LogicalOperator",
	"BinaryOperator",
	"Select",
	"SelectOptions",
	"SelectOption",
	"SelectColumn",
	"Aggregation",
	"AggregationOption",
	"SelectCount",
	"Renamed",
	"Cast",
	"Limit",
	"Offset",
	"Order",
	"Filter",
	"OrderOptions",
	"OrderOption",
	"ColumnName",
	"OrderDirection",
	"NullDirection",
	"Predicate",
	"Not",
	"Operator",
	"AnyAll",
	"Operand",
	"ListOperand",
	"ListOperandItem",
	"VectorOperand",
	"VectorOperandItem",
	"QuotedString",
	"EscapedChar",
	"ScalarOperand",
	"Integer",
	"END",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type PostgrestParser struct {
	Buffer string
	buffer []rune
	rules  [41]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *PostgrestParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *PostgrestParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *PostgrestParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *PostgrestParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *PostgrestParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *PostgrestParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*PostgrestParser) error {
	return func(p *PostgrestParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*PostgrestParser) error {
	return func(p *PostgrestParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *PostgrestParser) Init(options ...func(*PostgrestParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 QueryString <- <(QueryParam? ('&' QueryParam)* END)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[ruleQueryParam]() {
						goto l2
					}
					goto l3
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
			l3:
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if buffer[position] != rune('&') {
						goto l5
					}
					position++
					if !_rules[ruleQueryParam]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				if !_rules[ruleEND]() {
					goto l0
				}
				add(ruleQueryString, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 QueryParam <- <(Limit / Offset / Order / Select / LogicalQuery / Filter)> */
		func() bool {
			position6, tokenIndex6 := position, tokenIndex
			{
				position7 := position
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleLimit]() {
						goto l9
					}
					goto l8
				l9:
					position, tokenIndex = position8, tokenIndex8
					if !_rules[ruleOffset]() {
						goto l10
					}
					goto l8
				l10:
					position, tokenIndex = position8, tokenIndex8
					if !_rules[ruleOrder]() {
						goto l11
					}
					goto l8
				l11:
					position, tokenIndex = position8, tokenIndex8
					if !_rules[ruleSelect]() {
						goto l12
					}
					goto l8
				l12:
					position, tokenIndex = position8, tokenIndex8
					if !_rules[ruleLogicalQuery]() {
						goto l13
					}
					goto l8
				l13:
					position, tokenIndex = position8, tokenIndex8
					if !_rules[ruleFilter]() {
						goto l6
					}
				}
			l8:
				add(ruleQueryParam, position7)
			}
			return true
		l6:
			position, tokenIndex = position6, tokenIndex6
			return false
		},
		/* 2 LogicalQuery <- <(LogicalOperator '=' FilterList)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if !_rules[ruleLogicalOperator]() {
					goto l14
				}
				if buffer[position] != rune('=') {
					goto l14
				}
				position++
				if !_rules[ruleFilterList]() {
					goto l14
				}
				add(ruleLogicalQuery, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 FilterList <- <('(' FilterExpression (',' FilterExpression)* ')')> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				if buffer[position] != rune('(') {
					goto l16
				}
				position++
				if !_rules[ruleFilterExpression]() {
					goto l16
				}
			l18:
				{
					position19, tokenIndex19 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l19
					}
					position++
					if !_rules[ruleFilterExpression]() {
						goto l19
					}
					goto l18
				l19:
					position, tokenIndex = position19, tokenIndex19
				}
				if buffer[position] != rune(')') {
					goto l16
				}
				position++
				add(ruleFilterList, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 FilterExpression <- <(LogicalFilter / (ColumnName '.' Predicate))> */
		func() bool {
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				{
					position22, tokenIndex22 := position, tokenIndex
					if !_rules[ruleLogicalFilter]() {
						goto l23
					}
					goto l22
				l23:
					position, tokenIndex = position22, tokenIndex22
					if !_rules[ruleColumnName]() {
						goto l20
					}
					if buffer[position] != rune('.') {
						goto l20
					}
					position++
					if !_rules[rulePredicate]() {
						goto l20
					}
				}
			l22:
				add(ruleFilterExpression, position21)
			}
			return true
		l20:
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 5 LogicalFilter <- <(LogicalOperator FilterList)> */
		func() bool {
			position24, tokenIndex24 := position, tokenIndex
			{
				position25 := position
				if !_rules[ruleLogicalOperator]() {
					goto l24
				}
				if !_rules[ruleFilterList]() {
					goto l24
				}
				add(ruleLogicalFilter, position25)
			}
			return true
		l24:
			position, tokenIndex = position24, tokenIndex24
			return false
		},
		/* 6 LogicalOperator <- <(Not? BinaryOperator)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				{
					position28, tokenIndex28 := position, tokenIndex
					if !_rules[ruleNot]() {
						goto l28
					}
					goto l29
				l28:
					position, tokenIndex = position28, tokenIndex28
				}
			l29:
				if !_rules[ruleBinaryOperator]() {
					goto l26
				}
				add(ruleLogicalOperator, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 7 BinaryOperator <- <(('a' 'n' 'd') / ('o' 'r'))> */
		func() bool {
			position30, tokenIndex30 := position, tokenIndex
			{
				position31 := position
				{
					position32, tokenIndex32 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l33
					}
					position++
					if buffer[position] != rune('n') {
						goto l33
					}
					position++
					if buffer[position] != rune('d') {
						goto l33
					}
					position++
					goto l32
				l33:
					position, tokenIndex = position32, tokenIndex32
					if buffer[position] != rune('o') {
						goto l30
					}
					position++
					if buffer[position] != rune('r') {
						goto l30
					}
					position++
				}
			l32:
				add(ruleBinaryOperator, position31)
			}
			return true
		l30:
			position, tokenIndex = position30, tokenIndex30
			return false
		},
		/* 8 Select <- <('s' 'e' 'l' 'e' 'c' 't' '=' SelectOptions)> */
		func() bool {
			position34, tokenIndex34 := position, tokenIndex
			{
				position35 := position
				if buffer[position] != rune('s') {
					goto l34
				}
				position++
				if buffer[position] != rune('e') {
					goto l34
				}
				position++
				if buffer[position] != rune('l') {
					goto l34
				}
				position++
				if buffer[position] != rune('e') {
					goto l34
				}
				position++
				if buffer[position] != rune('c') {
					goto l34
				}
				position++
				if buffer[position] != rune('t') {
					goto l34
				}
				position++
				if buffer[position] != rune('=') {
					goto l34
				}
				position++
				if !_rules[ruleSelectOptions]() {
					goto l34
				}
				add(ruleSelect, position35)
			}
			return true
		l34:
			position, tokenIndex = position34, tokenIndex34
			return false
		},
		/* 9 SelectOptions <- <(SelectOption (',' SelectOption)*)> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				if !_rules[ruleSelectOption]() {
					goto l36
				}
			l38:
				{
					position39, tokenIndex39 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l39
					}
					position++
					if !_rules[ruleSelectOption]() {
						goto l39
					}
					goto l38
				l39:
					position, tokenIndex = position39, tokenIndex39
				}
				add(ruleSelectOptions, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 10 SelectOption <- <((Renamed ':' (SelectCount / SelectColumn) (':' ':') Cast) / (Renamed ':' (SelectCount / SelectColumn)) / ((SelectCount / SelectColumn) (':' ':') Cast) / (SelectCount / SelectColumn))> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				{
					position42, tokenIndex42 := position, tokenIndex
					if !_rules[ruleRenamed]() {
						goto l43
					}
					if buffer[position] != rune(':') {
						goto l43
					}
					position++
					{
						position44, tokenIndex44 := position, tokenIndex
						if !_rules[ruleSelectCount]() {
							goto l45
						}
						goto l44
					l45:
						position, tokenIndex = position44, tokenIndex44
						if !_rules[ruleSelectColumn]() {
							goto l43
						}
					}
				l44:
					if buffer[position] != rune(':') {
						goto l43
					}
					position++
					if buffer[position] != rune(':') {
						goto l43
					}
					position++
					if !_rules[ruleCast]() {
						goto l43
					}
					goto l42
				l43:
					position, tokenIndex = position42, tokenIndex42
					if !_rules[ruleRenamed]() {
						goto l46
					}
					if buffer[position] != rune(':') {
						goto l46
					}
					position++
					{
						position47, tokenIndex47 := position, tokenIndex
						if !_rules[ruleSelectCount]() {
							goto l48
						}
						goto l47
					l48:
						position, tokenIndex = position47, tokenIndex47
						if !_rules[ruleSelectColumn]() {
							goto l46
						}
					}
				l47:
					goto l42
				l46:
					position, tokenIndex = position42, tokenIndex42
					{
						position50, tokenIndex50 := position, tokenIndex
						if !_rules[ruleSelectCount]() {
							goto l51
						}
						goto l50
					l51:
						position, tokenIndex = position50, tokenIndex50
						if !_rules[ruleSelectColumn]() {
							goto l49
						}
					}
				l50:
					if buffer[position] != rune(':') {
						goto l49
					}
					position++
					if buffer[position] != rune(':') {
						goto l49
					}
					position++
					if !_rules[ruleCast]() {
						goto l49
					}
					goto l42
				l49:
					position, tokenIndex = position42, tokenIndex42
					{
						position52, tokenIndex52 := position, tokenIndex
						if !_rules[ruleSelectCount]() {
							goto l53
						}
						goto l52
					l53:
						position, tokenIndex = position52, tokenIndex52
						if !_rules[ruleSelectColumn]() {
							goto l40
						}
					}
				l52:
				}
			l42:
				add(ruleSelectOption, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 11 SelectColumn <- <((ColumnName (':' ':' Cast)? '.' Aggregation '(' AggregationOption? ')') / ColumnName)> */
		func() bool {
			position54, tokenIndex54 := position, tokenIndex
			{
				position55 := position
				{
					position56, tokenIndex56 := position, tokenIndex
					if !_rules[ruleColumnName]() {
						goto l57
					}
					{
						position58, tokenIndex58 := position, tokenIndex
						if buffer[position] != rune(':') {
							goto l58
						}
						position++
						if buffer[position] != rune(':') {
							goto l58
						}
						position++
						if !_rules[ruleCast]() {
							goto l58
						}
						goto l59
					l58:
						position, tokenIndex = position58, tokenIndex58
					}
				l59:
					if buffer[position] != rune('.') {
						goto l57
					}
					position++
					if !_rules[ruleAggregation]() {
						goto l57
					}
					if buffer[position] != rune('(') {
						goto l57
					}
					position++
					{
						position60, tokenIndex60 := position, tokenIndex
						if !_rules[ruleAggregationOption]() {
							goto l60
						}
						goto l61
					l60:
						position, tokenIndex = position60, tokenIndex60
					}
				l61:
					if buffer[position] != rune(')') {
						goto l57
					}
					position++
					goto l56
				l57:
					position, tokenIndex = position56, tokenIndex56
					if !_rules[ruleColumnName]() {
						goto l54
					}
				}
			l56:
				add(ruleSelectColumn, position55)
			}
			return true
		l54:
			position, tokenIndex = position54, tokenIndex54
			return false
		},
		/* 12 Aggregation <- <(!('=' / '&' / ',' / '.' / ':' / '(' / ')') .)+> */
		func() bool {
			position62, tokenIndex62 := position, tokenIndex
			{
				position63 := position
				{
					position66, tokenIndex66 := position, tokenIndex
					{
						position67, tokenIndex67 := position, tokenIndex
						if buffer[position] != rune('=') {
							goto l68
						}
						position++
						goto l67
					l68:
						position, tokenIndex = position67, tokenIndex67
						if buffer[position] != rune('&') {
							goto l69
						}
						position++
						goto l67
					l69:
						position, tokenIndex = position67, tokenIndex67
						if buffer[position] != rune(',') {
							goto l70
						}
						position++
						goto l67
					l70:
						position, tokenIndex = position67, tokenIndex67
						if buffer[position] != rune('.') {
							goto l71
						}
						position++
						goto l67
					l71:
						position, tokenIndex = position67, tokenIndex67
						if buffer[position] != rune(':') {
							goto l72
						}
						position++
						goto l67
					l72:
						position, tokenIndex = position67, tokenIndex67
						if buffer[position] != rune('(') {
							goto l73
						}
						position++
						goto l67
					l73:
						position, tokenIndex = position67, tokenIndex67
						if buffer[position] != rune(')') {
							goto l66
						}
						position++
					}
				l67:
					goto l62
				l66:
					position, tokenIndex = position66, tokenIndex66
				}
				if !matchDot() {
					goto l62
				}
			l64:
				{
					position65, tokenIndex65 := position, tokenIndex
					{
						position74, tokenIndex74 := position, tokenIndex
						{
							position75, tokenIndex75 := position, tokenIndex
							if buffer[position] != rune('=') {
								goto l76
							}
							position++
							goto l75
						l76:
							position, tokenIndex = position75, tokenIndex75
							if buffer[position] != rune('&') {
								goto l77
							}
							position++
							goto l75
						l77:
							position, tokenIndex = position75, tokenIndex75
							if buffer[position] != rune(',') {
								goto l78
							}
							position++
							goto l75
						l78:
							position, tokenIndex = position75, tokenIndex75
							if buffer[position] != rune('.') {
								goto l79
							}
							position++
							goto l75
						l79:
							position, tokenIndex = position75, tokenIndex75
							if buffer[position] != rune(':') {
								goto l80
							}
							position++
							goto l75
						l80:
							position, tokenIndex = position75, tokenIndex75
							if buffer[position] != rune('(') {
								goto l81
							}
							position++
							goto l75
						l81:
							position, tokenIndex = position75, tokenIndex75
							if buffer[position] != rune(')') {
								goto l74
							}
							position++
						}
					l75:
						goto l65
					l74:
						position, tokenIndex = position74, tokenIndex74
					}
					if !matchDot() {
						goto l65
					}
					goto l64
				l65:
					position, tokenIndex = position65, tokenIndex65
				}
				add(ruleAggregation, position63)
			}
			return true
		l62:
			position, tokenIndex = position62, tokenIndex62
			return false
		},
		/* 13 AggregationOption <- <(!('=' / '&' / ',' / '.' / ':' / '(' / ')') .)+> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				{
					position86, tokenIndex86 := position, tokenIndex
					{
						position87, tokenIndex87 := position, tokenIndex
						if buffer[position] != rune('=') {
							goto l88
						}
						position++
						goto l87
					l88:
						position, tokenIndex = position87, tokenIndex87
						if buffer[position] != rune('&') {
							goto l89
						}
						position++
						goto l87
					l89:
						position, tokenIndex = position87, tokenIndex87
						if buffer[position] != rune(',') {
							goto l90
						}
						position++
						goto l87
					l90:
						position, tokenIndex = position87, tokenIndex87
						if buffer[position] != rune('.') {
							goto l91
						}
						position++
						goto l87
					l91:
						position, tokenIndex = position87, tokenIndex87
						if buffer[position] != rune(':') {
							goto l92
						}
						position++
						goto l87
					l92:
						position, tokenIndex = position87, tokenIndex87
						if buffer[position] != rune('(') {
							goto l93
						}
						position++
						goto l87
					l93:
						position, tokenIndex = position87, tokenIndex87
						if buffer[position] != rune(')') {
							goto l86
						}
						position++
					}
				l87:
					goto l82
				l86:
					position, tokenIndex = position86, tokenIndex86
				}
				if !matchDot() {
					goto l82
				}
			l84:
				{
					position85, tokenIndex85 := position, tokenIndex
					{
						position94, tokenIndex94 := position, tokenIndex
						{
							position95, tokenIndex95 := position, tokenIndex
							if buffer[position] != rune('=') {
								goto l96
							}
							position++
							goto l95
						l96:
							position, tokenIndex = position95, tokenIndex95
							if buffer[position] != rune('&') {
								goto l97
							}
							position++
							goto l95
						l97:
							position, tokenIndex = position95, tokenIndex95
							if buffer[position] != rune(',') {
								goto l98
							}
							position++
							goto l95
						l98:
							position, tokenIndex = position95, tokenIndex95
							if buffer[position] != rune('.') {
								goto l99
							}
							position++
							goto l95
						l99:
							position, tokenIndex = position95, tokenIndex95
							if buffer[position] != rune(':') {
								goto l100
							}
							position++
							goto l95
						l100:
							position, tokenIndex = position95, tokenIndex95
							if buffer[position] != rune('(') {
								goto l101
							}
							position++
							goto l95
						l101:
							position, tokenIndex = position95, tokenIndex95
							if buffer[position] != rune(')') {
								goto l94
							}
							position++
						}
					l95:
						goto l85
					l94:
						position, tokenIndex = position94, tokenIndex94
					}
					if !matchDot() {
						goto l85
					}
					goto l84
				l85:
					position, tokenIndex = position85, tokenIndex85
				}
				add(ruleAggregationOption, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 14 SelectCount <- <('c' 'o' 'u' 'n' 't' '(' ')')> */
		func() bool {
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				if buffer[position] != rune('c') {
					goto l102
				}
				position++
				if buffer[position] != rune('o') {
					goto l102
				}
				position++
				if buffer[position] != rune('u') {
					goto l102
				}
				position++
				if buffer[position] != rune('n') {
					goto l102
				}
				position++
				if buffer[position] != rune('t') {
					goto l102
				}
				position++
				if buffer[position] != rune('(') {
					goto l102
				}
				position++
				if buffer[position] != rune(')') {
					goto l102
				}
				position++
				add(ruleSelectCount, position103)
			}
			return true
		l102:
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 15 Renamed <- <ColumnName> */
		func() bool {
			position104, tokenIndex104 := position, tokenIndex
			{
				position105 := position
				if !_rules[ruleColumnName]() {
					goto l104
				}
				add(ruleRenamed, position105)
			}
			return true
		l104:
			position, tokenIndex = position104, tokenIndex104
			return false
		},
		/* 16 Cast <- <(!('=' / '&' / ',' / '.' / ':') .)+> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				{
					position110, tokenIndex110 := position, tokenIndex
					{
						position111, tokenIndex111 := position, tokenIndex
						if buffer[position] != rune('=') {
							goto l112
						}
						position++
						goto l111
					l112:
						position, tokenIndex = position111, tokenIndex111
						if buffer[position] != rune('&') {
							goto l113
						}
						position++
						goto l111
					l113:
						position, tokenIndex = position111, tokenIndex111
						if buffer[position] != rune(',') {
							goto l114
						}
						position++
						goto l111
					l114:
						position, tokenIndex = position111, tokenIndex111
						if buffer[position] != rune('.') {
							goto l115
						}
						position++
						goto l111
					l115:
						position, tokenIndex = position111, tokenIndex111
						if buffer[position] != rune(':') {
							goto l110
						}
						position++
					}
				l111:
					goto l106
				l110:
					position, tokenIndex = position110, tokenIndex110
				}
				if !matchDot() {
					goto l106
				}
			l108:
				{
					position109, tokenIndex109 := position, tokenIndex
					{
						position116, tokenIndex116 := position, tokenIndex
						{
							position117, tokenIndex117 := position, tokenIndex
							if buffer[position] != rune('=') {
								goto l118
							}
							position++
							goto l117
						l118:
							position, tokenIndex = position117, tokenIndex117
							if buffer[position] != rune('&') {
								goto l119
							}
							position++
							goto l117
						l119:
							position, tokenIndex = position117, tokenIndex117
							if buffer[position] != rune(',') {
								goto l120
							}
							position++
							goto l117
						l120:
							position, tokenIndex = position117, tokenIndex117
							if buffer[position] != rune('.') {
								goto l121
							}
							position++
							goto l117
						l121:
							position, tokenIndex = position117, tokenIndex117
							if buffer[position] != rune(':') {
								goto l116
							}
							position++
						}
					l117:
						goto l109
					l116:
						position, tokenIndex = position116, tokenIndex116
					}
					if !matchDot() {
						goto l109
					}
					goto l108
				l109:
					position, tokenIndex = position109, tokenIndex109
				}
				add(ruleCast, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 17 Limit <- <('l' 'i' 'm' 'i' 't' '=' Integer)> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				if buffer[position] != rune('l') {
					goto l122
				}
				position++
				if buffer[position] != rune('i') {
					goto l122
				}
				position++
				if buffer[position] != rune('m') {
					goto l122
				}
				position++
				if buffer[position] != rune('i') {
					goto l122
				}
				position++
				if buffer[position] != rune('t') {
					goto l122
				}
				position++
				if buffer[position] != rune('=') {
					goto l122
				}
				position++
				if !_rules[ruleInteger]() {
					goto l122
				}
				add(ruleLimit, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 18 Offset <- <('o' 'f' 'f' 's' 'e' 't' '=' Integer)> */
		func() bool {
			position124, tokenIndex124 := position, tokenIndex
			{
				position125 := position
				if buffer[position] != rune('o') {
					goto l124
				}
				position++
				if buffer[position] != rune('f') {
					goto l124
				}
				position++
				if buffer[position] != rune('f') {
					goto l124
				}
				position++
				if buffer[position] != rune('s') {
					goto l124
				}
				position++
				if buffer[position] != rune('e') {
					goto l124
				}
				position++
				if buffer[position] != rune('t') {
					goto l124
				}
				position++
				if buffer[position] != rune('=') {
					goto l124
				}
				position++
				if !_rules[ruleInteger]() {
					goto l124
				}
				add(ruleOffset, position125)
			}
			return true
		l124:
			position, tokenIndex = position124, tokenIndex124
			return false
		},
		/* 19 Order <- <('o' 'r' 'd' 'e' 'r' '=' OrderOptions)> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if buffer[position] != rune('o') {
					goto l126
				}
				position++
				if buffer[position] != rune('r') {
					goto l126
				}
				position++
				if buffer[position] != rune('d') {
					goto l126
				}
				position++
				if buffer[position] != rune('e') {
					goto l126
				}
				position++
				if buffer[position] != rune('r') {
					goto l126
				}
				position++
				if buffer[position] != rune('=') {
					goto l126
				}
				position++
				if !_rules[ruleOrderOptions]() {
					goto l126
				}
				add(ruleOrder, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 20 Filter <- <(ColumnName '=' Predicate)> */
		func() bool {
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if !_rules[ruleColumnName]() {
					goto l128
				}
				if buffer[position] != rune('=') {
					goto l128
				}
				position++
				if !_rules[rulePredicate]() {
					goto l128
				}
				add(ruleFilter, position129)
			}
			return true
		l128:
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 21 OrderOptions <- <(OrderOption (',' OrderOption)*)> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				if !_rules[ruleOrderOption]() {
					goto l130
				}
			l132:
				{
					position133, tokenIndex133 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l133
					}
					position++
					if !_rules[ruleOrderOption]() {
						goto l133
					}
					goto l132
				l133:
					position, tokenIndex = position133, tokenIndex133
				}
				add(ruleOrderOptions, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 22 OrderOption <- <((ColumnName '.' OrderDirection '.' NullDirection) / (ColumnName '.' (OrderDirection / NullDirection)) / ColumnName)> */
		func() bool {
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				{
					position136, tokenIndex136 := position, tokenIndex
					if !_rules[ruleColumnName]() {
						goto l137
					}
					if buffer[position] != rune('.') {
						goto l137
					}
					position++
					if !_rules[ruleOrderDirection]() {
						goto l137
					}
					if buffer[position] != rune('.') {
						goto l137
					}
					position++
					if !_rules[ruleNullDirection]() {
						goto l137
					}
					goto l136
				l137:
					position, tokenIndex = position136, tokenIndex136
					if !_rules[ruleColumnName]() {
						goto l138
					}
					if buffer[position] != rune('.') {
						goto l138
					}
					position++
					{
						position139, tokenIndex139 := position, tokenIndex
						if !_rules[ruleOrderDirection]() {
							goto l140
						}
						goto l139
					l140:
						position, tokenIndex = position139, tokenIndex139
						if !_rules[ruleNullDirection]() {
							goto l138
						}
					}
				l139:
					goto l136
				l138:
					position, tokenIndex = position136, tokenIndex136
					if !_rules[ruleColumnName]() {
						goto l134
					}
				}
			l136:
				add(ruleOrderOption, position135)
			}
			return true
		l134:
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 23 ColumnName <- <(QuotedString / (!('=' / '&' / ',' / '.' / ':' / '(' / ')') .)+)> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				{
					position143, tokenIndex143 := position, tokenIndex
					if !_rules[ruleQuotedString]() {
						goto l144
					}
					goto l143
				l144:
					position, tokenIndex = position143, tokenIndex143
					{
						position147, tokenIndex147 := position, tokenIndex
						{
							position148, tokenIndex148 := position, tokenIndex
							if buffer[position] != rune('=') {
								goto l149
							}
							position++
							goto l148
						l149:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune('&') {
								goto l150
							}
							position++
							goto l148
						l150:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune(',') {
								goto l151
							}
							position++
							goto l148
						l151:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune('.') {
								goto l152
							}
							position++
							goto l148
						l152:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune(':') {
								goto l153
							}
							position++
							goto l148
						l153:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune('(') {
								goto l154
							}
							position++
							goto l148
						l154:
							position, tokenIndex = position148, tokenIndex148
							if buffer[position] != rune(')') {
								goto l147
							}
							position++
						}
					l148:
						goto l141
					l147:
						position, tokenIndex = position147, tokenIndex147
					}
					if !matchDot() {
						goto l141
					}
				l145:
					{
						position146, tokenIndex146 := position, tokenIndex
						{
							position155, tokenIndex155 := position, tokenIndex
							{
								position156, tokenIndex156 := position, tokenIndex
								if buffer[position] != rune('=') {
									goto l157
								}
								position++
								goto l156
							l157:
								position, tokenIndex = position156, tokenIndex156
								if buffer[position] != rune('&') {
									goto l158
								}
								position++
								goto l156
							l158:
								position, tokenIndex = position156, tokenIndex156
								if buffer[position] != rune(',') {
									goto l159
								}
								position++
								goto l156
							l159:
								position, tokenIndex = position156, tokenIndex156
								if buffer[position] != rune('.') {
									goto l160
								}
								position++
								goto l156
							l160:
								position, tokenIndex = position156, tokenIndex156
								if buffer[position] != rune(':') {
									goto l161
								}
								position++
								goto l156
							l161:
								position, tokenIndex = position156, tokenIndex156
								if buffer[position] != rune('(') {
									goto l162
								}
								position++
								goto l156
							l162:
								position, tokenIndex = position156, tokenIndex156
								if buffer[position] != rune(')') {
									goto l155
								}
								position++
							}
						l156:
							goto l146
						l155:
							position, tokenIndex = position155, tokenIndex155
						}
						if !matchDot() {
							goto l146
						}
						goto l145
					l146:
						position, tokenIndex = position146, tokenIndex146
					}
				}
			l143:
				add(ruleColumnName, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 24 OrderDirection <- <(('a' 's' 'c') / ('d' 'e' 's' 'c'))> */
		func() bool {
			position163, tokenIndex163 := position, tokenIndex
			{
				position164 := position
				{
					position165, tokenIndex165 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l166
					}
					position++
					if buffer[position] != rune('s') {
						goto l166
					}
					position++
					if buffer[position] != rune('c') {
						goto l166
					}
					position++
					goto l165
				l166:
					position, tokenIndex = position165, tokenIndex165
					if buffer[position] != rune('d') {
						goto l163
					}
					position++
					if buffer[position] != rune('e') {
						goto l163
					}
					position++
					if buffer[position] != rune('s') {
						goto l163
					}
					position++
					if buffer[position] != rune('c') {
						goto l163
					}
					position++
				}
			l165:
				add(ruleOrderDirection, position164)
			}
			return true
		l163:
			position, tokenIndex = position163, tokenIndex163
			return false
		},
		/* 25 NullDirection <- <(('n' 'u' 'l' 'l' 's' 'f' 'i' 'r' 's' 't') / ('n' 'u' 'l' 'l' 's' 'l' 'a' 's' 't'))> */
		func() bool {
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				{
					position169, tokenIndex169 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l170
					}
					position++
					if buffer[position] != rune('u') {
						goto l170
					}
					position++
					if buffer[position] != rune('l') {
						goto l170
					}
					position++
					if buffer[position] != rune('l') {
						goto l170
					}
					position++
					if buffer[position] != rune('s') {
						goto l170
					}
					position++
					if buffer[position] != rune('f') {
						goto l170
					}
					position++
					if buffer[position] != rune('i') {
						goto l170
					}
					position++
					if buffer[position] != rune('r') {
						goto l170
					}
					position++
					if buffer[position] != rune('s') {
						goto l170
					}
					position++
					if buffer[position] != rune('t') {
						goto l170
					}
					position++
					goto l169
				l170:
					position, tokenIndex = position169, tokenIndex169
					if buffer[position] != rune('n') {
						goto l167
					}
					position++
					if buffer[position] != rune('u') {
						goto l167
					}
					position++
					if buffer[position] != rune('l') {
						goto l167
					}
					position++
					if buffer[position] != rune('l') {
						goto l167
					}
					position++
					if buffer[position] != rune('s') {
						goto l167
					}
					position++
					if buffer[position] != rune('l') {
						goto l167
					}
					position++
					if buffer[position] != rune('a') {
						goto l167
					}
					position++
					if buffer[position] != rune('s') {
						goto l167
					}
					position++
					if buffer[position] != rune('t') {
						goto l167
					}
					position++
				}
			l169:
				add(ruleNullDirection, position168)
			}
			return true
		l167:
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 26 Predicate <- <(Not? ((Operator '.' Operand) / (Operator '(' AnyAll ')' '.' ListOperand)))> */
		func() bool {
			position171, tokenIndex171 := position, tokenIndex
			{
				position172 := position
				{
					position173, tokenIndex173 := position, tokenIndex
					if !_rules[ruleNot]() {
						goto l173
					}
					goto l174
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
			l174:
				{
					position175, tokenIndex175 := position, tokenIndex
					if !_rules[ruleOperator]() {
						goto l176
					}
					if buffer[position] != rune('.') {
						goto l176
					}
					position++
					if !_rules[ruleOperand]() {
						goto l176
					}
					goto l175
				l176:
					position, tokenIndex = position175, tokenIndex175
					if !_rules[ruleOperator]() {
						goto l171
					}
					if buffer[position] != rune('(') {
						goto l171
					}
					position++
					if !_rules[ruleAnyAll]() {
						goto l171
					}
					if buffer[position] != rune(')') {
						goto l171
					}
					position++
					if buffer[position] != rune('.') {
						goto l171
					}
					position++
					if !_rules[ruleListOperand]() {
						goto l171
					}
				}
			l175:
				add(rulePredicate, position172)
			}
			return true
		l171:
			position, tokenIndex = position171, tokenIndex171
			return false
		},
		/* 27 Not <- <('n' 'o' 't' '.')> */
		func() bool {
			position177, tokenIndex177 := position, tokenIndex
			{
				position178 := position
				if buffer[position] != rune('n') {
					goto l177
				}
				position++
				if buffer[position] != rune('o') {
					goto l177
				}
				position++
				if buffer[position] != rune('t') {
					goto l177
				}
				position++
				if buffer[position] != rune('.') {
					goto l177
				}
				position++
				add(ruleNot, position178)
			}
			return true
		l177:
			position, tokenIndex = position177, tokenIndex177
			return false
		},
		/* 28 Operator <- <([a-z] / [A-Z])+> */
		func() bool {
			position179, tokenIndex179 := position, tokenIndex
			{
				position180 := position
				{
					position183, tokenIndex183 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l184
					}
					position++
					goto l183
				l184:
					position, tokenIndex = position183, tokenIndex183
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l179
					}
					position++
				}
			l183:
			l181:
				{
					position182, tokenIndex182 := position, tokenIndex
					{
						position185, tokenIndex185 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l186
						}
						position++
						goto l185
					l186:
						position, tokenIndex = position185, tokenIndex185
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l182
						}
						position++
					}
				l185:
					goto l181
				l182:
					position, tokenIndex = position182, tokenIndex182
				}
				add(ruleOperator, position180)
			}
			return true
		l179:
			position, tokenIndex = position179, tokenIndex179
			return false
		},
		/* 29 AnyAll <- <(('a' 'n' 'y') / ('a' 'l' 'l'))> */
		func() bool {
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				{
					position189, tokenIndex189 := position, tokenIndex
					if buffer[position] != rune('a') {
						goto l190
					}
					position++
					if buffer[position] != rune('n') {
						goto l190
					}
					position++
					if buffer[position] != rune('y') {
						goto l190
					}
					position++
					goto l189
				l190:
					position, tokenIndex = position189, tokenIndex189
					if buffer[position] != rune('a') {
						goto l187
					}
					position++
					if buffer[position] != rune('l') {
						goto l187
					}
					position++
					if buffer[position] != rune('l') {
						goto l187
					}
					position++
				}
			l189:
				add(ruleAnyAll, position188)
			}
			return true
		l187:
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 30 Operand <- <(VectorOperand / ScalarOperand)> */
		func() bool {
			position191, tokenIndex191 := position, tokenIndex
			{
				position192 := position
				{
					position193, tokenIndex193 := position, tokenIndex
					if !_rules[ruleVectorOperand]() {
						goto l194
					}
					goto l193
				l194:
					position, tokenIndex = position193, tokenIndex193
					if !_rules[ruleScalarOperand]() {
						goto l191
					}
				}
			l193:
				add(ruleOperand, position192)
			}
			return true
		l191:
			position, tokenIndex = position191, tokenIndex191
			return false
		},
		/* 31 ListOperand <- <('{' ListOperandItem (',' ListOperandItem)* '}')> */
		func() bool {
			position195, tokenIndex195 := position, tokenIndex
			{
				position196 := position
				if buffer[position] != rune('{') {
					goto l195
				}
				position++
				if !_rules[ruleListOperandItem]() {
					goto l195
				}
			l197:
				{
					position198, tokenIndex198 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l198
					}
					position++
					if !_rules[ruleListOperandItem]() {
						goto l198
					}
					goto l197
				l198:
					position, tokenIndex = position198, tokenIndex198
				}
				if buffer[position] != rune('}') {
					goto l195
				}
				position++
				add(ruleListOperand, position196)
			}
			return true
		l195:
			position, tokenIndex = position195, tokenIndex195
			return false
		},
		/* 32 ListOperandItem <- <(QuotedString / (!(',' / '}' / '&' / '=') .)+)> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					if !_rules[ruleQuotedString]() {
						goto l202
					}
					goto l201
				l202:
					position, tokenIndex = position201, tokenIndex201
					{
						position205, tokenIndex205 := position, tokenIndex
						{
							position206, tokenIndex206 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l207
							}
							position++
							goto l206
						l207:
							position, tokenIndex = position206, tokenIndex206
							if buffer[position] != rune('}') {
								goto l208
							}
							position++
							goto l206
						l208:
							position, tokenIndex = position206, tokenIndex206
							if buffer[position] != rune('&') {
								goto l209
							}
							position++
							goto l206
						l209:
							position, tokenIndex = position206, tokenIndex206
							if buffer[position] != rune('=') {
								goto l205
							}
							position++
						}
					l206:
						goto l199
					l205:
						position, tokenIndex = position205, tokenIndex205
					}
					if !matchDot() {
						goto l199
					}
				l203:
					{
						position204, tokenIndex204 := position, tokenIndex
						{
							position210, tokenIndex210 := position, tokenIndex
							{
								position211, tokenIndex211 := position, tokenIndex
								if buffer[position] != rune(',') {
									goto l212
								}
								position++
								goto l211
							l212:
								position, tokenIndex = position211, tokenIndex211
								if buffer[position] != rune('}') {
									goto l213
								}
								position++
								goto l211
							l213:
								position, tokenIndex = position211, tokenIndex211
								if buffer[position] != rune('&') {
									goto l214
								}
								position++
								goto l211
							l214:
								position, tokenIndex = position211, tokenIndex211
								if buffer[position] != rune('=') {
									goto l210
								}
								position++
							}
						l211:
							goto l204
						l210:
							position, tokenIndex = position210, tokenIndex210
						}
						if !matchDot() {
							goto l204
						}
						goto l203
					l204:
						position, tokenIndex = position204, tokenIndex204
					}
				}
			l201:
				add(ruleListOperandItem, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 33 VectorOperand <- <('(' VectorOperandItem (',' VectorOperandItem)* ')')> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				if buffer[position] != rune('(') {
					goto l215
				}
				position++
				if !_rules[ruleVectorOperandItem]() {
					goto l215
				}
			l217:
				{
					position218, tokenIndex218 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l218
					}
					position++
					if !_rules[ruleVectorOperandItem]() {
						goto l218
					}
					goto l217
				l218:
					position, tokenIndex = position218, tokenIndex218
				}
				if buffer[position] != rune(')') {
					goto l215
				}
				position++
				add(ruleVectorOperand, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 34 VectorOperandItem <- <(QuotedString / (!(',' / ')' / '&' / '=') .)+)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				{
					position221, tokenIndex221 := position, tokenIndex
					if !_rules[ruleQuotedString]() {
						goto l222
					}
					goto l221
				l222:
					position, tokenIndex = position221, tokenIndex221
					{
						position225, tokenIndex225 := position, tokenIndex
						{
							position226, tokenIndex226 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l227
							}
							position++
							goto l226
						l227:
							position, tokenIndex = position226, tokenIndex226
							if buffer[position] != rune(')') {
								goto l228
							}
							position++
							goto l226
						l228:
							position, tokenIndex = position226, tokenIndex226
							if buffer[position] != rune('&') {
								goto l229
							}
							position++
							goto l226
						l229:
							position, tokenIndex = position226, tokenIndex226
							if buffer[position] != rune('=') {
								goto l225
							}
							position++
						}
					l226:
						goto l219
					l225:
						position, tokenIndex = position225, tokenIndex225
					}
					if !matchDot() {
						goto l219
					}
				l223:
					{
						position224, tokenIndex224 := position, tokenIndex
						{
							position230, tokenIndex230 := position, tokenIndex
							{
								position231, tokenIndex231 := position, tokenIndex
								if buffer[position] != rune(',') {
									goto l232
								}
								position++
								goto l231
							l232:
								position, tokenIndex = position231, tokenIndex231
								if buffer[position] != rune(')') {
									goto l233
								}
								position++
								goto l231
							l233:
								position, tokenIndex = position231, tokenIndex231
								if buffer[position] != rune('&') {
									goto l234
								}
								position++
								goto l231
							l234:
								position, tokenIndex = position231, tokenIndex231
								if buffer[position] != rune('=') {
									goto l230
								}
								position++
							}
						l231:
							goto l224
						l230:
							position, tokenIndex = position230, tokenIndex230
						}
						if !matchDot() {
							goto l224
						}
						goto l223
					l224:
						position, tokenIndex = position224, tokenIndex224
					}
				}
			l221:
				add(ruleVectorOperandItem, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 35 QuotedString <- <('"' (EscapedChar / (!('"' / '&' / '=') .))* '"')> */
		func() bool {
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				if buffer[position] != rune('"') {
					goto l235
				}
				position++
			l237:
				{
					position238, tokenIndex238 := position, tokenIndex
					{
						position239, tokenIndex239 := position, tokenIndex
						if !_rules[ruleEscapedChar]() {
							goto l240
						}
						goto l239
					l240:
						position, tokenIndex = position239, tokenIndex239
						{
							position241, tokenIndex241 := position, tokenIndex
							{
								position242, tokenIndex242 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l243
								}
								position++
								goto l242
							l243:
								position, tokenIndex = position242, tokenIndex242
								if buffer[position] != rune('&') {
									goto l244
								}
								position++
								goto l242
							l244:
								position, tokenIndex = position242, tokenIndex242
								if buffer[position] != rune('=') {
									goto l241
								}
								position++
							}
						l242:
							goto l238
						l241:
							position, tokenIndex = position241, tokenIndex241
						}
						if !matchDot() {
							goto l238
						}
					}
				l239:
					goto l237
				l238:
					position, tokenIndex = position238, tokenIndex238
				}
				if buffer[position] != rune('"') {
					goto l235
				}
				position++
				add(ruleQuotedString, position236)
			}
			return true
		l235:
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 36 EscapedChar <- <('\\' .)> */
		func() bool {
			position245, tokenIndex245 := position, tokenIndex
			{
				position246 := position
				if buffer[position] != rune('\\') {
					goto l245
				}
				position++
				if !matchDot() {
					goto l245
				}
				add(ruleEscapedChar, position246)
			}
			return true
		l245:
			position, tokenIndex = position245, tokenIndex245
			return false
		},
		/* 37 ScalarOperand <- <(!('&' / '=' / ',' / '(' / ')' / '{' / '}') .)+> */
		func() bool {
			position247, tokenIndex247 := position, tokenIndex
			{
				position248 := position
				{
					position251, tokenIndex251 := position, tokenIndex
					{
						position252, tokenIndex252 := position, tokenIndex
						if buffer[position] != rune('&') {
							goto l253
						}
						position++
						goto l252
					l253:
						position, tokenIndex = position252, tokenIndex252
						if buffer[position] != rune('=') {
							goto l254
						}
						position++
						goto l252
					l254:
						position, tokenIndex = position252, tokenIndex252
						if buffer[position] != rune(',') {
							goto l255
						}
						position++
						goto l252
					l255:
						position, tokenIndex = position252, tokenIndex252
						if buffer[position] != rune('(') {
							goto l256
						}
						position++
						goto l252
					l256:
						position, tokenIndex = position252, tokenIndex252
						if buffer[position] != rune(')') {
							goto l257
						}
						position++
						goto l252
					l257:
						position, tokenIndex = position252, tokenIndex252
						if buffer[position] != rune('{') {
							goto l258
						}
						position++
						goto l252
					l258:
						position, tokenIndex = position252, tokenIndex252
						if buffer[position] != rune('}') {
							goto l251
						}
						position++
					}
				l252:
					goto l247
				l251:
					position, tokenIndex = position251, tokenIndex251
				}
				if !matchDot() {
					goto l247
				}
			l249:
				{
					position250, tokenIndex250 := position, tokenIndex
					{
						position259, tokenIndex259 := position, tokenIndex
						{
							position260, tokenIndex260 := position, tokenIndex
							if buffer[position] != rune('&') {
								goto l261
							}
							position++
							goto l260
						l261:
							position, tokenIndex = position260, tokenIndex260
							if buffer[position] != rune('=') {
								goto l262
							}
							position++
							goto l260
						l262:
							position, tokenIndex = position260, tokenIndex260
							if buffer[position] != rune(',') {
								goto l263
							}
							position++
							goto l260
						l263:
							position, tokenIndex = position260, tokenIndex260
							if buffer[position] != rune('(') {
								goto l264
							}
							position++
							goto l260
						l264:
							position, tokenIndex = position260, tokenIndex260
							if buffer[position] != rune(')') {
								goto l265
							}
							position++
							goto l260
						l265:
							position, tokenIndex = position260, tokenIndex260
							if buffer[position] != rune('{') {
								goto l266
							}
							position++
							goto l260
						l266:
							position, tokenIndex = position260, tokenIndex260
							if buffer[position] != rune('}') {
								goto l259
							}
							position++
						}
					l260:
						goto l250
					l259:
						position, tokenIndex = position259, tokenIndex259
					}
					if !matchDot() {
						goto l250
					}
					goto l249
				l250:
					position, tokenIndex = position250, tokenIndex250
				}
				add(ruleScalarOperand, position248)
			}
			return true
		l247:
			position, tokenIndex = position247, tokenIndex247
			return false
		},
		/* 38 Integer <- <[0-9]+> */
		func() bool {
			position267, tokenIndex267 := position, tokenIndex
			{
				position268 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l267
				}
				position++
			l269:
				{
					position270, tokenIndex270 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l270
					}
					position++
					goto l269
				l270:
					position, tokenIndex = position270, tokenIndex270
				}
				add(ruleInteger, position268)
			}
			return true
		l267:
			position, tokenIndex = position267, tokenIndex267
			return false
		},
		/* 39 END <- <!.> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				{
					position273, tokenIndex273 := position, tokenIndex
					if !matchDot() {
						goto l273
					}
					goto l271
				l273:
					position, tokenIndex = position273, tokenIndex273
				}
				add(ruleEND, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
	}
	p.rules = _rules
	return nil
}
